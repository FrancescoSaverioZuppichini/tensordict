
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "tutorials/data_fashion.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_tutorials_data_fashion.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_tutorials_data_fashion.py:


Using TensorDict for datasets
=============================

.. GENERATED FROM PYTHON SOURCE LINES 9-14

In this tutorial we demonstrate how ``TensorDict`` can be used to
efficiently and transparently load and manage data inside a training
pipeline. The tutorial is based heavily on the `PyTorch Quickstart
Tutorial <https://pytorch.org/tutorials/beginner/basics/quickstart_tutorial.html>`__,
but modified to demonstrate use of ``TensorDict``.

.. GENERATED FROM PYTHON SOURCE LINES 14-27

.. code-block:: default



    import torch
    import torch.nn as nn
    from tensordict import MemmapTensor, TensorDict
    from torch.utils.data import DataLoader
    from torchvision import datasets
    from torchvision.transforms import ToTensor

    device = "cuda" if torch.cuda.is_available() else "cpu"
    print(f"Using device: {device}")






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Using device: cpu




.. GENERATED FROM PYTHON SOURCE LINES 28-32

The ``torchvision.datasets`` module contains a number of convenient pre-prepared
datasets. In this tutorial we'll use the relatively simple FashionMNIST dataset. Each
image is an item of clothing, the objective is to classify the type of clothing in
the image (e.g. "Bag", "Sneaker" etc.).

.. GENERATED FROM PYTHON SOURCE LINES 32-46

.. code-block:: default


    training_data = datasets.FashionMNIST(
        root="data",
        train=True,
        download=True,
        transform=ToTensor(),
    )
    test_data = datasets.FashionMNIST(
        root="data",
        train=False,
        download=True,
        transform=ToTensor(),
    )





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Downloading http://fashion-mnist.s3-website.eu-central-1.amazonaws.com/train-images-idx3-ubyte.gz
    Downloading http://fashion-mnist.s3-website.eu-central-1.amazonaws.com/train-images-idx3-ubyte.gz to data/FashionMNIST/raw/train-images-idx3-ubyte.gz
      0%|          | 0/26421880 [00:00<?, ?it/s]      0%|          | 65536/26421880 [00:00<01:13, 356352.58it/s]      1%|          | 163840/26421880 [00:00<00:43, 610192.93it/s]      2%|1         | 458752/26421880 [00:00<00:22, 1170402.64it/s]      5%|5         | 1343488/26421880 [00:00<00:07, 3379026.73it/s]     14%|#3        | 3571712/26421880 [00:00<00:03, 7353777.01it/s]     32%|###1      | 8421376/26421880 [00:00<00:01, 17595508.12it/s]     47%|####7     | 12550144/26421880 [00:01<00:00, 19975731.69it/s]     66%|######5   | 17399808/26421880 [00:01<00:00, 26469058.78it/s]     81%|########  | 21299200/26421880 [00:01<00:00, 24931059.36it/s]    100%|##########| 26421880/26421880 [00:01<00:00, 18844500.31it/s]
    Extracting data/FashionMNIST/raw/train-images-idx3-ubyte.gz to data/FashionMNIST/raw

    Downloading http://fashion-mnist.s3-website.eu-central-1.amazonaws.com/train-labels-idx1-ubyte.gz
    Downloading http://fashion-mnist.s3-website.eu-central-1.amazonaws.com/train-labels-idx1-ubyte.gz to data/FashionMNIST/raw/train-labels-idx1-ubyte.gz
      0%|          | 0/29515 [00:00<?, ?it/s]    100%|##########| 29515/29515 [00:00<00:00, 316200.14it/s]
    Extracting data/FashionMNIST/raw/train-labels-idx1-ubyte.gz to data/FashionMNIST/raw

    Downloading http://fashion-mnist.s3-website.eu-central-1.amazonaws.com/t10k-images-idx3-ubyte.gz
    Downloading http://fashion-mnist.s3-website.eu-central-1.amazonaws.com/t10k-images-idx3-ubyte.gz to data/FashionMNIST/raw/t10k-images-idx3-ubyte.gz
      0%|          | 0/4422102 [00:00<?, ?it/s]      1%|1         | 65536/4422102 [00:00<00:12, 347037.39it/s]      4%|3         | 163840/4422102 [00:00<00:07, 601580.32it/s]     10%|9         | 425984/4422102 [00:00<00:03, 1054875.10it/s]     30%|##9       | 1310720/4422102 [00:00<00:00, 3274637.63it/s]     79%|#######8  | 3473408/4422102 [00:00<00:00, 7033990.81it/s]    100%|##########| 4422102/4422102 [00:00<00:00, 5827886.77it/s]
    Extracting data/FashionMNIST/raw/t10k-images-idx3-ubyte.gz to data/FashionMNIST/raw

    Downloading http://fashion-mnist.s3-website.eu-central-1.amazonaws.com/t10k-labels-idx1-ubyte.gz
    Downloading http://fashion-mnist.s3-website.eu-central-1.amazonaws.com/t10k-labels-idx1-ubyte.gz to data/FashionMNIST/raw/t10k-labels-idx1-ubyte.gz
      0%|          | 0/5148 [00:00<?, ?it/s]    100%|##########| 5148/5148 [00:00<00:00, 50098090.47it/s]
    Extracting data/FashionMNIST/raw/t10k-labels-idx1-ubyte.gz to data/FashionMNIST/raw





.. GENERATED FROM PYTHON SOURCE LINES 47-53

We will create two tensordicts, one each for the training and test data. We create
memory-mapped tensors to hold the data. This will allow us to efficiently load
batches of transformed data from disk rather than repeatedly load and transform
individual images.

First we create the ``MemmapTensor`` containers.

.. GENERATED FROM PYTHON SOURCE LINES 53-78

.. code-block:: default



    training_data_td = TensorDict(
        {
            "images": MemmapTensor(
                len(training_data),
                *training_data[0][0].squeeze().shape,
                dtype=torch.float32,
            ),
            "targets": MemmapTensor(len(training_data), dtype=torch.int64),
        },
        batch_size=[len(training_data)],
        device=device,
    )
    test_data_td = TensorDict(
        {
            "images": MemmapTensor(
                len(test_data), *test_data[0][0].squeeze().shape, dtype=torch.float32
            ),
            "targets": MemmapTensor(len(test_data), dtype=torch.int64),
        },
        batch_size=[len(test_data)],
        device=device,
    )








.. GENERATED FROM PYTHON SOURCE LINES 79-82

Then we can iterate over the data to populate the memory-mapped tensors. This takes a
bit of time, but performing the transforms up-front will save repeated effort during
training later.

.. GENERATED FROM PYTHON SOURCE LINES 82-89

.. code-block:: default


    for i, (img, label) in enumerate(training_data):
        training_data_td[i] = TensorDict({"images": img, "targets": label}, [])

    for i, (img, label) in enumerate(test_data):
        test_data_td[i] = TensorDict({"images": img, "targets": label}, [])








.. GENERATED FROM PYTHON SOURCE LINES 90-100

DataLoaders
----------------

We'll create DataLoaders from the ``torchvision``-provided Datasets, as well as from
our memory-mapped TensorDicts.

Since ``TensorDict`` implements ``__len__`` and ``__getitem__`` (and also
``__getitems__``) we can use it like a map-style Dataset and create a ``DataLoader``
directly from it. Note that because ``TensorDict`` can already handle batched indices,
there is no need for collation, so we pass the identity function as ``collate_fn``.

.. GENERATED FROM PYTHON SOURCE LINES 100-113

.. code-block:: default


    batch_size = 64

    train_dataloader = DataLoader(training_data, batch_size=batch_size)
    test_dataloader = DataLoader(test_data, batch_size=batch_size)

    train_dataloader_td = DataLoader(
        training_data_td, batch_size=batch_size, collate_fn=lambda x: x
    )
    test_dataloader_td = DataLoader(
        test_data_td, batch_size=batch_size, collate_fn=lambda x: x
    )








.. GENERATED FROM PYTHON SOURCE LINES 114-120

Model
-------

We use the same model from the
`Quickstart Tutorial <https://pytorch.org/tutorials/beginner/basics/quickstart_tutorial.html>`__.


.. GENERATED FROM PYTHON SOURCE LINES 120-144

.. code-block:: default



    class Net(nn.Module):
        def __init__(self):
            super().__init__()
            self.flatten = nn.Flatten()
            self.linear_relu_stack = nn.Sequential(
                nn.Linear(28 * 28, 512),
                nn.ReLU(),
                nn.Linear(512, 512),
                nn.ReLU(),
                nn.Linear(512, 10),
            )

        def forward(self, x):
            x = self.flatten(x)
            logits = self.linear_relu_stack(x)
            return logits


    model = Net().to(device)
    model_td = Net().to(device)
    model, model_td





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    (Net(
      (flatten): Flatten(start_dim=1, end_dim=-1)
      (linear_relu_stack): Sequential(
        (0): Linear(in_features=784, out_features=512, bias=True)
        (1): ReLU()
        (2): Linear(in_features=512, out_features=512, bias=True)
        (3): ReLU()
        (4): Linear(in_features=512, out_features=10, bias=True)
      )
    ), Net(
      (flatten): Flatten(start_dim=1, end_dim=-1)
      (linear_relu_stack): Sequential(
        (0): Linear(in_features=784, out_features=512, bias=True)
        (1): ReLU()
        (2): Linear(in_features=512, out_features=512, bias=True)
        (3): ReLU()
        (4): Linear(in_features=512, out_features=10, bias=True)
      )
    ))



.. GENERATED FROM PYTHON SOURCE LINES 145-151

Optimizing the parameters
---------------------------------

We'll optimise the parameters of the model using stochastic gradient descent and
cross-entropy loss.


.. GENERATED FROM PYTHON SOURCE LINES 151-176

.. code-block:: default


    loss_fn = nn.CrossEntropyLoss()
    optimizer = torch.optim.SGD(model.parameters(), lr=1e-3)
    optimizer_td = torch.optim.SGD(model_td.parameters(), lr=1e-3)


    def train(dataloader, model, loss_fn, optimizer):
        size = len(dataloader.dataset)
        model.train()

        for batch, (X, y) in enumerate(dataloader):
            X, y = X.to(device), y.to(device)

            pred = model(X)
            loss = loss_fn(pred, y)

            optimizer.zero_grad()
            loss.backward()
            optimizer.step()

            if batch % 100 == 0:
                loss, current = loss.item(), batch * len(X)
                print(f"loss: {loss:>7f} [{current:>5d}/{size:>5d}]")









.. GENERATED FROM PYTHON SOURCE LINES 177-180

The training loop for our ``TensorDict``-based DataLoader is very similar, we just
adjust how we unpack the data to the more explicit key-based retrieval offered by
``TensorDict``. The ``.contiguous()`` method loads the data stored in the memmap tensor.

.. GENERATED FROM PYTHON SOURCE LINES 180-266

.. code-block:: default



    def train_td(dataloader, model, loss_fn, optimizer):
        size = len(dataloader.dataset)
        model.train()

        for batch, data in enumerate(dataloader):
            X, y = data["images"].contiguous(), data["targets"].contiguous()

            pred = model(X)
            loss = loss_fn(pred, y)

            optimizer.zero_grad()
            loss.backward()
            optimizer.step()

            if batch % 100 == 0:
                loss, current = loss.item(), batch * len(X)
                print(f"loss: {loss:>7f} [{current:>5d}/{size:>5d}]")


    def test(dataloader, model, loss_fn):
        size = len(dataloader.dataset)
        num_batches = len(dataloader)
        model.eval()
        test_loss, correct = 0, 0
        with torch.no_grad():
            for X, y in dataloader:
                X, y = X.to(device), y.to(device)

                pred = model(X)

                test_loss += loss_fn(pred, y).item()
                correct += (pred.argmax(1) == y).type(torch.float).sum().item()

        test_loss /= num_batches
        correct /= size

        print(
            f"Test Error: \n Accuracy: {(100 * correct):>0.1f}%, Avg loss: {test_loss:>8f} \n"
        )


    def test_td(dataloader, model, loss_fn):
        size = len(dataloader.dataset)
        num_batches = len(dataloader)
        model.eval()
        test_loss, correct = 0, 0
        with torch.no_grad():
            for batch in dataloader:
                X, y = batch["images"].contiguous(), batch["targets"].contiguous()

                pred = model(X)

                test_loss += loss_fn(pred, y).item()
                correct += (pred.argmax(1) == y).type(torch.float).sum().item()

        test_loss /= num_batches
        correct /= size

        print(
            f"Test Error: \n Accuracy: {(100 * correct):>0.1f}%, Avg loss: {test_loss:>8f} \n"
        )


    for d in train_dataloader_td:
        print(d)
        break

    import time

    t0 = time.time()
    epochs = 5
    for t in range(epochs):
        print(f"Epoch {t + 1}\n-------------------------")
        train_td(train_dataloader_td, model_td, loss_fn, optimizer_td)
        test_td(test_dataloader_td, model_td, loss_fn)
    print(f"TensorDict training done! time: {time.time() - t0: 4.4f} s")

    t0 = time.time()
    epochs = 5
    for t in range(epochs):
        print(f"Epoch {t + 1}\n-------------------------")
        train(train_dataloader, model, loss_fn, optimizer)
        test(test_dataloader, model, loss_fn)
    print(f"Training done! time: {time.time() - t0: 4.4f} s")




.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    TensorDict(
        fields={
            images: MemmapTensor(shape=torch.Size([64, 28, 28]), device=cpu, dtype=torch.float32, is_shared=False),
            targets: MemmapTensor(shape=torch.Size([64]), device=cpu, dtype=torch.int64, is_shared=False)},
        batch_size=torch.Size([64]),
        device=cpu,
        is_shared=False)
    Epoch 1
    -------------------------
    loss: 2.311912 [    0/60000]
    loss: 2.293898 [ 6400/60000]
    loss: 2.277237 [12800/60000]
    loss: 2.259335 [19200/60000]
    loss: 2.244674 [25600/60000]
    loss: 2.227641 [32000/60000]
    loss: 2.215824 [38400/60000]
    loss: 2.191750 [44800/60000]
    loss: 2.188335 [51200/60000]
    loss: 2.157599 [57600/60000]
    Test Error: 
     Accuracy: 47.3%, Avg loss: 2.149539 

    Epoch 2
    -------------------------
    loss: 2.166587 [    0/60000]
    loss: 2.151986 [ 6400/60000]
    loss: 2.092838 [12800/60000]
    loss: 2.096396 [19200/60000]
    loss: 2.041675 [25600/60000]
    loss: 1.990485 [32000/60000]
    loss: 2.004023 [38400/60000]
    loss: 1.926972 [44800/60000]
    loss: 1.938043 [51200/60000]
    loss: 1.853708 [57600/60000]
    Test Error: 
     Accuracy: 50.8%, Avg loss: 1.859634 

    Epoch 3
    -------------------------
    loss: 1.898779 [    0/60000]
    loss: 1.869074 [ 6400/60000]
    loss: 1.748337 [12800/60000]
    loss: 1.781875 [19200/60000]
    loss: 1.664935 [25600/60000]
    loss: 1.625014 [32000/60000]
    loss: 1.645906 [38400/60000]
    loss: 1.549842 [44800/60000]
    loss: 1.587918 [51200/60000]
    loss: 1.471709 [57600/60000]
    Test Error: 
     Accuracy: 57.9%, Avg loss: 1.498968 

    Epoch 4
    -------------------------
    loss: 1.565140 [    0/60000]
    loss: 1.538788 [ 6400/60000]
    loss: 1.390068 [12800/60000]
    loss: 1.457580 [19200/60000]
    loss: 1.341748 [25600/60000]
    loss: 1.338606 [32000/60000]
    loss: 1.355080 [38400/60000]
    loss: 1.278496 [44800/60000]
    loss: 1.329041 [51200/60000]
    loss: 1.220274 [57600/60000]
    Test Error: 
     Accuracy: 62.0%, Avg loss: 1.250080 

    Epoch 5
    -------------------------
    loss: 1.322537 [    0/60000]
    loss: 1.310882 [ 6400/60000]
    loss: 1.147115 [12800/60000]
    loss: 1.251312 [19200/60000]
    loss: 1.134291 [25600/60000]
    loss: 1.152236 [32000/60000]
    loss: 1.175001 [38400/60000]
    loss: 1.107926 [44800/60000]
    loss: 1.165788 [51200/60000]
    loss: 1.068116 [57600/60000]
    Test Error: 
     Accuracy: 64.2%, Avg loss: 1.092691 

    TensorDict training done! time:  12.4373 s
    Epoch 1
    -------------------------
    loss: 2.300215 [    0/60000]
    loss: 2.283027 [ 6400/60000]
    loss: 2.273084 [12800/60000]
    loss: 2.271866 [19200/60000]
    loss: 2.246877 [25600/60000]
    loss: 2.222689 [32000/60000]
    loss: 2.236573 [38400/60000]
    loss: 2.196465 [44800/60000]
    loss: 2.198428 [51200/60000]
    loss: 2.180497 [57600/60000]
    Test Error: 
     Accuracy: 40.7%, Avg loss: 2.163108 

    Epoch 2
    -------------------------
    loss: 2.169534 [    0/60000]
    loss: 2.158497 [ 6400/60000]
    loss: 2.110029 [12800/60000]
    loss: 2.124555 [19200/60000]
    loss: 2.079139 [25600/60000]
    loss: 2.018198 [32000/60000]
    loss: 2.051377 [38400/60000]
    loss: 1.970083 [44800/60000]
    loss: 1.976467 [51200/60000]
    loss: 1.912778 [57600/60000]
    Test Error: 
     Accuracy: 57.6%, Avg loss: 1.909007 

    Epoch 3
    -------------------------
    loss: 1.934066 [    0/60000]
    loss: 1.908542 [ 6400/60000]
    loss: 1.803376 [12800/60000]
    loss: 1.833729 [19200/60000]
    loss: 1.730292 [25600/60000]
    loss: 1.680436 [32000/60000]
    loss: 1.696242 [38400/60000]
    loss: 1.599561 [44800/60000]
    loss: 1.621829 [51200/60000]
    loss: 1.517751 [57600/60000]
    Test Error: 
     Accuracy: 62.2%, Avg loss: 1.539260 

    Epoch 4
    -------------------------
    loss: 1.599782 [    0/60000]
    loss: 1.567087 [ 6400/60000]
    loss: 1.425715 [12800/60000]
    loss: 1.485180 [19200/60000]
    loss: 1.370237 [25600/60000]
    loss: 1.371414 [32000/60000]
    loss: 1.374419 [38400/60000]
    loss: 1.303106 [44800/60000]
    loss: 1.338459 [51200/60000]
    loss: 1.241569 [57600/60000]
    Test Error: 
     Accuracy: 63.4%, Avg loss: 1.268056 

    Epoch 5
    -------------------------
    loss: 1.343162 [    0/60000]
    loss: 1.323676 [ 6400/60000]
    loss: 1.164929 [12800/60000]
    loss: 1.259534 [19200/60000]
    loss: 1.138646 [25600/60000]
    loss: 1.171875 [32000/60000]
    loss: 1.180868 [38400/60000]
    loss: 1.122084 [44800/60000]
    loss: 1.162905 [51200/60000]
    loss: 1.083586 [57600/60000]
    Test Error: 
     Accuracy: 64.4%, Avg loss: 1.101616 

    Training done! time:  33.9586 s





.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 1 minutes  1.202 seconds)


.. _sphx_glr_download_tutorials_data_fashion.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example


    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: data_fashion.py <data_fashion.py>`

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: data_fashion.ipynb <data_fashion.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
